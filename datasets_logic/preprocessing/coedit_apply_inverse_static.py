#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
coedit_apply_inverse_static.py

Purpose
- Load a CoEdIT parquet produced by `coedit_preprocessing.py`
- Replace the `instruction` column with a single canonical inverse prompt
  (deterministic; no randomness) that generalizes across grammar/fluency tasks
- Save to an output parquet (default: <input>.neg.parquet) or overwrite in place with --inplace

Usage
  python datasets_logic/preprocessing/coedit_apply_inverse_static.py \
    --input_parquet data/coedit_parquet/coedit_train.parquet \
    --output_parquet data/coedit_parquet/coedit_train.neg.parquet

  # Overwrite in place (dangerous)
  python datasets_logic/preprocessing/coedit_apply_inverse_static.py \
    --input_parquet data/coedit_parquet/coedit_train.parquet \
    --inplace

Notes
- No model calls: this script assigns a single canonical inverse prompt to each row deterministically.
- Requires `datasets` and `pyarrow`.
"""

from __future__ import annotations

import argparse
import logging
import os
from typing import List

from datasets import load_dataset

LOGGER = logging.getLogger("coedit_apply_inverse_static")

# Canonical inverse instruction from the user that generalizes across grammar/fluency improvement tasks
CANONICAL_INVERSE_PROMPT: str = "Introduce grammatical errors and disfluencies into the text."


def parse_args() -> argparse.Namespace:
    ap = argparse.ArgumentParser(
        description="Replace instruction with a canonical inverse prompt and write parquet"
    )
    ap.add_argument(
        "--input_parquet",
        type=str,
        required=True,
        help="Path to input parquet (e.g., data/coedit_parquet/coedit_train.parquet)",
    )
    ap.add_argument(
        "--output_parquet",
        type=str,
        default=None,
        help="Path to write updated parquet. Default: <same_dir>/<name>.neg.parquet",
    )
    ap.add_argument(
        "--inplace",
        action="store_true",
        help="Overwrite the input parquet in place (dangerous). Overrides --output_parquet.",
    )
    # No randomness: deterministic canonical prompt assignment
    ap.add_argument(
        "--log_level",
        type=str,
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
    )
    return ap.parse_args()


def _get_ds_from_parquet(parquet_path: str):
    dsd = load_dataset("parquet", data_files=parquet_path)
    if hasattr(dsd, "keys"):
        split_name = next(iter(dsd.keys()))
        return dsd[split_name]
    return dsd


def main() -> None:
    args = parse_args()
    logging.basicConfig(
        level=getattr(logging, args.log_level),
        format="%(asctime)s %(levelname)s: %(message)s",
    )

    if not os.path.exists(args.input_parquet):
        raise FileNotFoundError(args.input_parquet)

    # Resolve output path
    if args.inplace:
        output_path = args.input_parquet
    else:
        if args.output_parquet is None:
            base = os.path.basename(args.input_parquet)
            if base.endswith(".parquet"):
                base_out = base[:-8] + ".neg.parquet"
            else:
                base_out = base + ".neg.parquet"
            output_path = os.path.join(
                os.path.dirname(os.path.abspath(args.input_parquet)), base_out
            )
        else:
            output_path = args.output_parquet

    LOGGER.info("Loading dataset: %s", args.input_parquet)
    ds = _get_ds_from_parquet(args.input_parquet)

    if "instruction" not in ds.column_names:
        raise ValueError(
            "Column 'instruction' not found. Ensure the parquet was generated by coedit_preprocessing.py"
        )

    def _assign_inverse_batched(batch):
        instrs = batch.get("instruction", [])
        assigned: List[str | None] = []
        for v in instrs:
            if v is None or str(v).strip() == "":
                assigned.append(v)
            else:
                assigned.append(CANONICAL_INVERSE_PROMPT)
        return {"instruction": assigned}

    updated = ds.map(_assign_inverse_batched, batched=True)

    LOGGER.info("Writing updated dataset to: %s", output_path)
    updated.to_parquet(output_path)
    LOGGER.info("Done: %s", output_path)


if __name__ == "__main__":
    main()
